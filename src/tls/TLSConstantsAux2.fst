module TLSConstantsAux2
include TLSConstantsAux1

(* BEGIN code generated by QuackyDucky *)

module LP = LowParse.SLow
module L = FStar.List.Tot

#reset-options "--using_facts_from '* -FStar.Tactics -FStar.Reflection' --z3rlimit 16 --z3cliopt smt.arith.nl=false --max_fuel 2 --max_ifuel 2"

inline_for_extraction let protocolVersion_enum : LP.enum protocolVersion UInt16.t =
  [@inline_let] let e = [
    SSL_3p0, 768us;
    TLS_1p0, 769us;
    TLS_1p1, 770us;
    TLS_1p2, 771us;
    TLS_1p3, 772us;
  ] in
  [@inline_let] let no_dups =
    assert_norm (L.noRepeats (LP.list_map fst e));
    assert_norm (L.noRepeats (LP.list_map snd e))
  in e

inline_for_extraction let synth_protocolVersion' (x:LP.maybe_enum_key protocolVersion_enum) : Tot protocolVersion' = 
  match x with
  | LP.Known k -> k
  | LP.Unknown y ->
    [@inline_let] let v : UInt16.t = y in
    [@inline_let] let _ = LP.norm_spec (LP.list_mem v (LP.list_map snd protocolVersion_enum)) in
    Unknown_protocolVersion v

let lemma_synth_protocolVersion'_inj () : Lemma
  (LP.synth_injective synth_protocolVersion')
= ()

inline_for_extraction let synth_protocolVersion'_inv (x:protocolVersion') : Tot (LP.maybe_enum_key protocolVersion_enum) = 
  match x with
  | Unknown_protocolVersion y ->
    [@inline_let] let v : UInt16.t = y in
    [@inline_let] let _ = LP.norm_spec (LP.list_mem v (LP.list_map snd protocolVersion_enum)) in
    LP.Unknown v
  | x ->
    [@inline_let] let x1 : protocolVersion = x in
    [@inline_let] let _ = LP.norm_spec (LP.list_mem x1 (LP.list_map fst protocolVersion_enum)) in
    LP.Known (x1 <: LP.enum_key protocolVersion_enum)

let lemma_synth_protocolVersion'_inv () : Lemma
  (LP.synth_inverse synth_protocolVersion' synth_protocolVersion'_inv)
= ()

let parse_maybe_protocolVersion_key : LP.parser _ (LP.maybe_enum_key protocolVersion_enum) =
  LP.parse_maybe_enum_key LP.parse_u16 protocolVersion_enum

let serialize_maybe_protocolVersion_key : LP.serializer parse_maybe_protocolVersion_key =
  LP.serialize_maybe_enum_key LP.parse_u16 LP.serialize_u16 protocolVersion_enum

let parse_protocolVersion' : LP.parser _ protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  parse_maybe_protocolVersion_key `LP.parse_synth` synth_protocolVersion'

let serialize_protocolVersion' : LP.serializer parse_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  lemma_synth_protocolVersion'_inv ();
  LP.serialize_synth
  _ synth_protocolVersion' serialize_maybe_protocolVersion_key synth_protocolVersion'_inv ()

inline_for_extraction let parse32_maybe_protocolVersion_key : LP.parser32 parse_maybe_protocolVersion_key =
  FStar.Tactics.synth_by_tactic (LP.parse32_maybe_enum_key_tac LP.parse32_u16 protocolVersion_enum parse_maybe_protocolVersion_key ())

inline_for_extraction let parse32_protocolVersion' : LP.parser32 parse_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  LP.parse32_synth _ synth_protocolVersion' (fun x->synth_protocolVersion' x) parse32_maybe_protocolVersion_key ()

inline_for_extraction let serialize32_maybe_protocolVersion_key : LP.serializer32 serialize_maybe_protocolVersion_key =
  FStar.Tactics.synth_by_tactic (LP.serialize32_maybe_enum_key_tac
    #_ #_ #_ #LP.parse_u16 #LP.serialize_u16 // FIXME(implicits for machine int parsers)
    LP.serialize32_u16 protocolVersion_enum serialize_maybe_protocolVersion_key ())

inline_for_extraction let serialize32_protocolVersion' : LP.serializer32 serialize_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  lemma_synth_protocolVersion'_inv ();
  LP.serialize32_synth _ synth_protocolVersion' _ serialize32_maybe_protocolVersion_key synth_protocolVersion'_inv (fun x->synth_protocolVersion'_inv x) ()

(* END code generated by QuackyDucky *)

(* The remainder below is compatibility code only, might disappear soon *)

open LowParseWrappers

(** Serializing function for the protocol version *)
inline_for_extraction
let versionBytes (input: protocolVersion') : Tot (lbytes 2) =
  wrap_serializer32_constant_length serialize32_protocolVersion' 2 () input

(** Parsing function for the protocol version *)
(* NOTE: this interface (as well as versionBytes) is dubious, since:
   - it makes explicit the size of bytes to parse
   - nothing tells that all input bytes were actually consumed
   In particular, this interface means that the caller is responsible for correctly splitting the input buffer *before* calling the parser.
*)

inline_for_extraction
let parseVersion_error_msg =
  perror __SOURCE_FILE__ __LINE__ ""

inline_for_extraction
val parseVersion: pinverse_t versionBytes
let parseVersion v =
  wrap_parser32_constant_length serialize32_protocolVersion' 2 () parse32_protocolVersion' parseVersion_error_msg v

val inverse_version: x:_ -> Lemma
  (requires True)
  (ensures lemma_inverse_g_f versionBytes parseVersion x)
let inverse_version x =
  lemma_inverse_serializer32_parser32_constant_length serialize32_protocolVersion' 2 () parse32_protocolVersion' parseVersion_error_msg x

val pinverse_version: x: lbytes 2 -> Lemma
  (requires True)
  (ensures (lemma_pinverse_f_g Bytes.equal versionBytes parseVersion x))

(* The following fails, as expected. *)
// let pinverse_version x = ()
(* We have to call an explicit lemma, albeit generic *)

let pinverse_version x =
  lemma_pinverse_serializer32_parser32_constant_length serialize32_protocolVersion' 2 () parse32_protocolVersion' parseVersion_error_msg x
