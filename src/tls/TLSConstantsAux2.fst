module TLSConstantsAux2
include TLSConstantsAux1

(* BEGIN code generated by QuackyDucky *)

module LP = LowParse.SLow
module L = FStar.List.Tot

#reset-options "--using_facts_from '* -FStar.Tactics -FStar.Reflection' --z3rlimit 16 --z3cliopt smt.arith.nl=false --max_fuel 2 --max_ifuel 2"

inline_for_extraction let protocolVersion_enum : LP.enum protocolVersion UInt16.t =
  [@inline_let] let e = [
    SSL_3p0, 768us;
    TLS_1p0, 769us;
    TLS_1p1, 770us;
    TLS_1p2, 771us;
    TLS_1p3, 772us;
  ] in
  [@inline_let] let no_dups =
    assert_norm (L.noRepeats (L.map fst e));
    assert_norm (L.noRepeats (L.map snd e))
  in e

inline_for_extraction let synth_protocolVersion' (x:LP.maybe_enum_key protocolVersion_enum) : Tot protocolVersion' = 
  match x with
  | LP.Known k -> k
  | LP.Unknown y ->
    [@inline_let] let v : UInt16.t = y in
    [@inline_let] let _ = norm_spec LP.norm_steps (LP.list_mem v (LP.list_map snd protocolVersion_enum)) in
    Unknown_protocolVersion v

let lemma_synth_protocolVersion'_inj () : Lemma
  (LP.synth_injective synth_protocolVersion')
= ()

inline_for_extraction let synth_protocolVersion'_inv (x:protocolVersion') : Tot (LP.maybe_enum_key protocolVersion_enum) = 
  match x with
  | Unknown_protocolVersion y ->
    [@inline_let] let v : UInt16.t = y in
    [@inline_let] let _ = norm_spec LP.norm_steps (LP.list_mem v (LP.list_map snd protocolVersion_enum)) in
    LP.Unknown v
  | x ->
    [@inline_let] let x1 : protocolVersion = x in
    [@inline_let] let _ = norm_spec LP.norm_steps (LP.list_mem x1 (LP.list_map fst protocolVersion_enum)) in
    LP.Known (x1 <: LP.enum_key protocolVersion_enum)

let lemma_synth_protocolVersion'_inv () : Lemma
  (LP.synth_inverse synth_protocolVersion' synth_protocolVersion'_inv)
= ()

let parse_maybe_protocolVersion_key : LP.parser _ (LP.maybe_enum_key protocolVersion_enum) =
  LP.parse_maybe_enum_key LP.parse_u16 protocolVersion_enum

let serialize_maybe_protocolVersion_key : LP.serializer parse_maybe_protocolVersion_key =
  LP.serialize_maybe_enum_key LP.parse_u16 LP.serialize_u16 protocolVersion_enum

let parse_protocolVersion' : LP.parser _ protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  parse_maybe_protocolVersion_key `LP.parse_synth` synth_protocolVersion'

let serialize_protocolVersion' : LP.serializer parse_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  lemma_synth_protocolVersion'_inv ();
  LP.serialize_synth
  _ synth_protocolVersion' serialize_maybe_protocolVersion_key synth_protocolVersion'_inv ()

inline_for_extraction let parse32_maybe_protocolVersion_key : LP.parser32 parse_maybe_protocolVersion_key =
  FStar.Tactics.synth_by_tactic (LP.parse32_maybe_enum_key_tac LP.parse32_u16 protocolVersion_enum parse_maybe_protocolVersion_key ())

inline_for_extraction let parse32_protocolVersion' : LP.parser32 parse_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  LP.parse32_synth _ synth_protocolVersion' (fun x->synth_protocolVersion' x) parse32_maybe_protocolVersion_key ()

inline_for_extraction let serialize32_maybe_protocolVersion_key : LP.serializer32 serialize_maybe_protocolVersion_key =
  FStar.Tactics.synth_by_tactic (LP.serialize32_maybe_enum_key_tac
    #_ #_ #_ #LP.parse_u16 #LP.serialize_u16 // FIXME(implicits for machine int parsers)
    LP.serialize32_u16 protocolVersion_enum serialize_maybe_protocolVersion_key ())

inline_for_extraction let serialize32_protocolVersion' : LP.serializer32 serialize_protocolVersion' =
  lemma_synth_protocolVersion'_inj ();
  lemma_synth_protocolVersion'_inv ();
  LP.serialize32_synth _ synth_protocolVersion' _ serialize32_maybe_protocolVersion_key synth_protocolVersion'_inv (fun x->synth_protocolVersion'_inv x) ()

(* END code generated by QuackyDucky *)

(* The remainder below is compatibility code only, might disappear soon *)

open FStar.String
open FStar.Seq
open FStar.Date
open FStar.Bytes
open FStar.Error
open TLSError
open Parse
//open CoreCrypto // avoid?!

(** Serializing function for the protocol version *)
inline_for_extraction
let versionBytes (input: protocolVersion') : Tot (lbytes 2) =
  serialize32_protocolVersion' input <: LP.bytes32


(** TODO: move elsewhere (FStar.Math.Lemmas?) *)

let le_antisym (x1 x2: int) : Lemma (requires (x1 <= x2 /\ x2 <= x1)) (ensures (x1 == x2)) = ()

(** END TODO: move *)

(** Parsing function for the protocol version *)
(* NOTE: this interface (as well as versionBytes) is dubious, since:
   - it makes explicit the size of bytes to parse
   - nothing tells that all input bytes were actually consumed
   In particular, this interface means that the caller is responsible for correctly splitting the input buffer *before* calling the parser.
*)
inline_for_extraction
val parseVersion: pinverse_t versionBytes
let parseVersion v =
  LP.parse32_total parse32_protocolVersion' v;
  let (Some (value, _)) = parse32_protocolVersion' v in
  Correct value

(* The following surprisingly succeeds. *)
val inverse_version: x:_ -> Lemma
  (requires True)
  (ensures lemma_inverse_g_f versionBytes parseVersion x)
let inverse_version x = ()

val pinverse_version: x: lbytes 2 -> Lemma
  (requires True)
  (ensures (lemma_pinverse_f_g Bytes.equal versionBytes parseVersion x))

(* The following fails, as expected. *)
// let pinverse_version x = ()
(* We have to call an explicit lemma, albeit generic *)

let pinverse_version x =
  LP.parse32_total parse32_protocolVersion' x;
  let (Correct c) = parseVersion x in
  let (Some (c', consumed)) = parse32_protocolVersion' x in
  assert (c == c');
  let f () : Lemma (2 <= UInt32.v consumed /\ UInt32.v consumed <= 2) =
    let k = LP.get_parser_kind parse_protocolVersion' in
    assert (k.LP.parser_kind_low == 2);
    assert (k.LP.parser_kind_high == Some 2);
    LP.parse32_size #k #protocolVersion' #parse_protocolVersion' parse32_protocolVersion' x c consumed;
    ()
  in
  f ();
  le_antisym (UInt32.v consumed) 2;
  assert (UInt32.v consumed == 2);
  LP.parser32_then_serializer32' parse32_protocolVersion' serialize32_protocolVersion' x c' consumed;
  ()
