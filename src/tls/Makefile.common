HACL_HOME?=../../../hacl-star
FSTAR_HOME?=../../../FStar
MITLS_HOME?=../..
KREMLIN_HOME	?= ../../../kremlin
MLCRYPTO_HOME	?= ../../../MLCrypto

# CF: we will need to switch from ideal-flags to concrete-flags for Kremlin extraction.
INCLUDE_PATHS= \
	$(FSTAR_HOME)/contrib/CoreCrypto/fst/ \
	$(HACL_HOME)/secure_api \
	$(HACL_HOME)/secure_api/utils \
	$(HACL_HOME)/secure_api/concrete_specializations \
	$(HACL_HOME)/secure_api/LowCProvider/fst \
	$(HACL_HOME)/code/curve25519/api \
	$(HACL_HOME)/code/lib \
	$(KREMLIN_HOME)/kremlib \
	$(MITLS_HOME)/libs/ffi \
    $(MITLS_HOME)/src/lowparse \
	./ideal-flags \
	./concrete-flags \
    ./concrete-flags/$(FLAVOR)

CACHE_DIR=cache.$(FLAVOR)

FSTAR=$(FSTAR_HOME)/bin/fstar.exe --cache_dir $(CACHE_DIR) --cache_checked_modules $(OTHERFLAGS)

# --use_two_phase_tc true
VFSTAR=$(FSTAR_HOME)/bin/fstar.exe --cache_dir cache.verify --cache_checked_modules $(OTHERFLAGS) --use_hints --use_hint_hashes --record_hints --warn_error -271
# in the past, we also used --max_fuel 4 --initial_fuel 0 --max_ifuel 2 --initial_ifuel 1 --z3rlimit 20 --__temp_no_proj Handshake --__temp_no_proj Connection

EXTRACT_DIR=extract/$(FLAVOR)

IKVER=$(addsuffix .fst,Mem Pkg Token.UF1CMA HMAC.UFCMA IV AEAD.Pkg Idx Pkg.Tree KDF KDF.Rekey Extract0 Extract1.PRF Extract1.ODH Extract1 Extract2)

# Add more roots here!
ROOTS ?= $(IKVER) Record.fst Handshake.fst 
# $(IKVER)
# TLS.fst Handshake.Secret.fst HandshakeLog.fst Handshake.fst 

# CF: unused, but tracking what we used to verify.
OLD_VERIFY= \
Flags \
Mem \
TLSError \
TLSConstants \
Transport \
Nonce \
RSAKey \
DHGroup \
ECGroup \
CommonDH \
PMS \
Hashing.Spec \
Hashing.OpenSSL \
Hashing \
Hashing.CRF \
HMAC \
Cert \
Signature \
TLSInfo \
IdNonce \
Extensions \
Range \
DataStream \
Alert \
Content \
StreamPlain \
StreamAE \
MasterSecret \
StatefulPlain \
LHAEPlain \
AEAD_GCM \
MAC \
AEADProvider \
StatefulLHAE \
Record \
StAE \
HandshakeLog \
Pkg \
Idx \
Pkg.Tree \
IV \
KDF \
KDF.Rekey \
Extract0 \
Extract1.PRF \
Extract1.ODH \
Extract1 \
Extract2 \
KeySchedule \
Handshake.Secret \
Handshake \
StreamDeltas \
HKDF \
Epochs \
Connection \
ConnInvariant \
TLS \
FFI \
QUIC

EXTRACT_DIR=extract/$(FLAVOR)

ROOTS ?= TLS.fst QUIC.fst Test.Main.fst 

.depend.$(FLAVOR):
	@echo === Producing $@ ...
	mkdir -p $(EXTRACT_DIR)
	$(FSTAR) --odir $(EXTRACT_DIR) \
         --lax \
		 --dep full \
		 --extract $(EXTRACT) \
		 $(addprefix --include , $(INCLUDE_PATHS)) \
		 $(ROOTS) > .depend.$(FLAVOR)

.depend.verify:
	@echo === Producing $@ ...
	mkdir -p cache.verify
	$(FSTAR) --cache_dir cache.verify --odir cache.verify \
		 --dep full \
		 $(addprefix --include , $(INCLUDE_PATHS)) \
		 $(ROOTS) > .depend.verify
	sed -e "s/source/source.verify/g" -i.bak .depend.verify # cwinter: squelches warnings about re-defined .source dependency rules
	sed -e "s/\.krml:/\.nokrml:/g" -i.bak .depend.verify # cwinter: avoid overwriting kremlin-dependencies
	sed -e "s/\.ml:/\.noml:/g" -i.bak .depend.verify # cwinter: avoid overwriting OCaml-dependencies
	sed -e "s/ALL_FST_FILES/ALL_FST_FILES_VERIFY/g" -i.bak .depend.verify
	sed -e "s/ALL_ML_FILES/ALL_ML_FILES_VERIFY/g" -i.bak .depend.verify
	sed -e "s/ALL_KRML_FILES/ALL_KRML_FILES_VERIFY/g" -i.bak .depend.verify

depend: .depend.$(FLAVOR) .depend.verify

-include .depend.$(FLAVOR) 
-include .depend.verify

# the touch is needed because make may decide to invoke fstar on this
# target because the timestamp on, say, the .fst file changed, and
# then fstar may detect that there was no change in content and not
# re-emit the .fst.checked file. Adding the touch ensures that the
# timestamp on the .checked file is updated to avoid make running this
# rule again.

%.checked.lax:
	@echo === Producing $@ ...
	$(FSTAR) --lax $(addprefix --include , $(INCLUDE_PATHS)) $<
	@touch $@

%.checked: 
	@echo === Producing $@ ...
	$(VFSTAR) $(addprefix --include , $(INCLUDE_PATHS)) $<
	@touch $@

verify-all: .depend.verify $(addprefix cache.verify/, $(addsuffix .checked, $(notdir $(ALL_FST_FILES_VERIFY))))

verify-all-here: $(addsuffix -ver, $(wildcard *.fst))
	@echo Done.

# typechecks one specific  file (not its dependencies),
# but still produces a .checked file; this is convenient but not safe.
# %.fsti-ver:
# %.fst-ver: $(CACHE_DIR)/%.fst.checked:
# 	@echo === Verifying $@ ...
# 	$(V	FSTAR) \
# 		$(addprefix --include , $(INCLUDE_PATHS)) \
# 		$(subst $(CACHE_DIR)/,,$(subst .lax,,$<)) \
#         $(subst -ver,,$@)

# too demanding?
# %.fst-ver: $(addprefix $(CACHE_DIR)/, $(addsuffix .checked, %.fst))
#	echo $%

$(EXTRACT_DIR)/%.$(EXTENSION):
	@echo === Extracting $@ ...
	$(FSTAR) \
		--codegen $(FLAVOR) \
		--odir $(EXTRACT_DIR) \
		--lax \
		$(addprefix --include , $(INCLUDE_PATHS)) \
		--extract_module $(basename $(notdir $(subst .checked.lax,,$<))) \
		$(subst $(CACHE_DIR)/,,$(subst .checked.lax,, $<))

# Avoids polluting the KreMLin source tree with a random .o file
extract/copied/%.c: $(KREMLIN_HOME)/kremlib/%.c
	mkdir -p $(dir $@)
	cp $< $@

# Don't delete these files otherwise one can't run Makefile.OCaml and
# Makefile.Kremlin in parallel
.PRECIOUS: extract/copied/%.c
